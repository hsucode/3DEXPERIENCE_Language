<meta charset="UTF-8"/>
PackageName="创成式函数";

CATKnowledge.EndModifyTemplate.Description="每次调用 CreateOrModifyTemplate/InstantiateTemplate 以完成实例化后调用 <p><span style=\"font-size:12px;\"></span><span style=\"font-weight:bold;font-size:12px;\">EndModifyTemplate</span><span style=\"font-size:12px;\">。不调用此函数将导致求值错误。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">模板</span><span style=\"\">（特征）：要完成的模板示例</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">无</span><//p>";
CATKnowledge.EndModifyTemplate.Sample="@idem CATPackageGenerativeKnowledge.InstantiateTemplate";

CATKnowledge.CreateOrModifyTemplate.Description="<p><span style=\"font-size:12px;\">仅在知识工程阵列中。</span><br/><span style=\"font-size:12px;\">此函数在当前环境（本地资源表或数据设置）中查找要实例化的模板，该模板与指定作为输入的名称匹配，将该模板在指定的目标对象下实例化。</span><br/><span style=\"font-size:12px;\">已创建的特征将添加到指定索引的指定阵列中。如果索引为 0，项目将附加到列表。</span><br/><span style=\"font-size:12px;\"></span><//p><p><span style=\"font-weight:bold;font-size:12px;\">CreateOrModifyTemplate</span><span style=\"font-size:12px;\">（仅在知识工程阵列中），此函数在当前环境（本地资源表或数据设置）中查找要实例化的模板，该模板与指定作为输入的名称匹配，将该模板在指定的目标对象下实例化。</span><br/><span style=\"font-size:12px;\">已创建的特征将添加到指定索引的指定阵列中。如果索引为 0，项目将附加到列表。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">templateId (ARM)</span><span style=\"\">（字符串）：模板逻辑名称（来自本地资源表或数据设置）</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">destination</span><span style=\"\">（特征）：实例化的目标</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">patternList</span><span style=\"\">（列表）：存储结果的阵列列表</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">indexInPatternList</span><span style=\"\">（整数）：指示对象必须插入到列表中的位置的可选指数。默认行为是将结果附加到列表。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">- UndefinedType：返回已实例化的模板对象。可在此对象上设置输入和参数值，且必须在此对象上调用 EndModifyTemplate 以完成实例化。</span><//p>";
CATKnowledge.CreateOrModifyTemplate.Sample="/* This code instantiates a Template named TriangularPad which takes three points (defined on the template as A,B and C) as inputs and a length for the pad (called PadLength) as parameter. */\nlet templateInstance(Feature)\nlet p1,p2,p3(Point)\nlet destinationOfInstantiation(Feature)\n[...] /* Gather inputs here */\n\ntemplateInstance = CreateOrModifyTemplate(\"TriangularPad\",destinationOfInstantiation,`Relations\Knowledge Pattern.1\List.1`)\nif templateInstance <> NULL \n{\n\t/* Set inputs */\n\ttemplateInstance->SetAttributeObject(\"A\",p1)\n\ttemplateInstance->SetAttributeObject(\"B\",p2)\n\ttemplateInstance->SetAttributeObject(\"C\",p3)\n\t/* Set Parameter */\n\ttemplateInstance->SetAttributeDimension(\"PadLength\",50mm,\"Length\")\n\tEndModifyTemplate(templateInstance)\n}\n\n";

CATKnowledge.CreateConstraint.Description="<p><span style=\"font-weight:bold;color:rgb(0,0,0);font-size:12px;\"></span><//p><p><span style=\"font-weight:bold;color:rgb(0,0,0);font-size:12px;\">PLMEntity->CreateConstraint </span><span style=\"color:rgb(0,0,0);font-size:12px;\">在调用的对象下创建定位约束。</span><br/><span style=\"color:rgb(0,0,0);font-size:12px;\">如果两个指定部件之间不存在任何工程连接，则将创建一个。</span><//p><p><span style=\"color:rgb(0,0,0);font-size:12px;\">约束的类型确定可以约束的对象，请参阅文档，以了解每个约束类型的可用对象类型表。</span><//p><p><span style=\"font-weight:bold;color:rgb(0,0,0);font-size:12px;\">输入：</span><//p><p><span style=\"font-weight:bold;color:rgb(0,0,0);font-size:12px;\">- name</span><span style=\"color:rgb(0,0,0);font-size:12px;\">（字符串）：要创建的约束名称。如果创建此名称，将用于命名工程约束。</span><//p><p><span style=\"color:rgb(0,0,0);\">- </span><span style=\"font-weight:bold;color:rgb(0,0,0);\">类型</span><span style=\"color:rgb(0,0,0);\">（字符串）：要创建的约束类型。可用类型有：角度、铰链、相合、接触、距离、固定、固定交换、固联、固联交换、长度、平行、垂直、投影、滚动、滑动、对称和相切。</span><//p><p><span style=\"color:rgb(0,0,0);\">- </span><span style=\"font-weight:bold;color:rgb(0,0,0);\">元素</span><span style=\"color:rgb(0,0,0);\">(ObjectType)：要约束的对象。</span><span style=\"color:rgb(0,0,0);font-size:12px;\">要约束的约束可以是 KWEPointer 对象（位于专有技术应用程序上下文中）或通过 CreatePathString 创建的字符串，直接指向特征或指向发布。</span><//p><p><span style=\"font-weight:bold;color:rgb(0,0,0);font-size:12px;\">返回值：</span><//p><p><span style=\"color:rgb(0,0,0);\">- UndefinedType：此方法成功后创建的约束 (MRX)</span><//p><p><span style=\"color:rgb(0,0,0);\"></span><//p>";
CATKnowledge.CreateConstraint.Sample="/* \n\tThis sample creates a coincidence constraint between \n\tan axle's axis and a wheel's axis, both are published \n\tright on the instance they belong to under the name \n\t\"AxisForConstraint\" \n*/ \n \nlet assemblyRoot(VPMReference) \nlet wheelInstance(VPMInstance) \nlet axleInstance(VPMInstance) \nlet pathOfAxleAxis(String) \nlet pathOfWheelAxis(String) \nlet createdCoincidence(MRXCoincidence) \n \n [...] \n \npathOfAxleAxis = assemblyRoot->CreatePathString(axleInstance,\"AxisForConstraint\") \npathOfWheelAxis = assemblyRoot->CreatePathString(wheelInstance,\"AxisForConstraint\") \n \ncreatedCoincidence = assemblyRoot->CreateConstraint(\"MyConstraintName\",\"Coincidence\",pathOfAxleAxis,pathOfWheelAxis) \n\n\n\n\n";

CATKnowledge.CreatePathString.Description="<p><span style=\"font-size:12px;\"></span><br/><span style=\"font-size:12px;\"></span><span style=\"font-weight:bold;font-size:12px;\">PLMEntity->CreatePathString</span><span style=\"font-size:12px;\">返回路径字符串，始于调用此字符串的对象，终于指定为输入的元素。路径字符串是用于识别多实例化上下文中产品结构内的唯一特征的方式。</span><br/><span style=\"font-size:12px;\">使用此函数构建的字符串用于多个其他函数（CreateConstraint、Access、CenterGraph...）。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">实例</span><span style=\"\">(VPMInstance)：</span><span style=\"font-size:12px;\"></span><span style=\"font-size:12px;\">可为 CreatePathString 函数提供一个实例，以解决应在创建路径时使用哪个实例的混淆问题。</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">元素</span><span style=\"\">(ObjectType)：</span><span style=\"font-size:12px;\"></span><span style=\"font-size:12px;\">所构建路径上的元素应直接是一个特征或包含发布名称的字符串。在第二个案例中，发布必须位于路径中指定的上一实例下。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">- 字符串：此路径作为 String，包含其包含的所有元素的名称。</span><//p><p/><p><span style=\"font-weight:bold;font-size:12px;\">PLMEntity->CreatePathString</span><span style=\"font-size:12px;\">上述 cf.，仅第一个参数</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">实例</span><span style=\"\">（列表）：构建路径时使用的实例列表。实例的顺序必须正确。</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">元素</span><span style=\"\">(ObjectType)：上述 cf.。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">- 字符串：上述 cf.</span><//p>";
CATKnowledge.CreatePathString.Sample="@idem CATPackageGenerativeKnowledge.CreateConstraint";

CATKnowledge.CreatePublication.Description="<p><span style=\"font-size:12px;\"></span><//p><p><span style=\"font-size:12px;\"></span><span style=\"font-weight:bold;font-size:12px;\">PLMEntity->CreatePublication</span><span style=\"font-size:12px;\">所调用参考的输入名称下发布指定特征。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">实例</span><span style=\"\">(VPMInstance)：</span><span style=\"font-size:12px;\">可提供一个实例作为输入，以解决多实例化上下文的混淆问题，如果为空，可选择任何可用的实例路径。</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">已发布元素</span><span style=\"\">(ObjectType)：</span><span style=\"font-size:12px;\">发布的特征可以是直接是一个特征或 KWEPointer（位于专有技术应用程序上下文中）。</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">名称</span><span style=\"\">（字符串）：发布名称。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">无</span><//p>";
CATKnowledge.CreatePublication.Sample="/* \n\tThis sample searches for a point named \"CenterOfGravity\" and publishes it \n\tunder the same name. \n*/ \nlet refToPublishOn(VPMReference) \nlet pointToPublish(Point) \nlet instanceContainingThePoint(VPMInstance) \n\n[...] \n \npointToPublish = refToPublishOn->Find(\"Point\",\"x.Name==\\"CenterOfGravity\\"\",TRUE) \n \nrefToPublishOn->CreatePublication(instanceContainingThePoint, /* Can be NULL if no ambiguity */ \n\t\t\t\t\t\t\t\t\tpointToPublish, \n\t\t\t\t\t\t\t\t\t\"CenterOfGravity\") \n\n\n";

CATKnowledge.ReplaceInstance.Description="<p><span style=\"font-size:12px;\"></span><//p><p><span style=\"font-weight:bold;font-size:12px;\">ReplaceInstance</span><span style=\"font-size:12px;\">使用现有结构中另一指定参考的实例替换现有实例。该函数等同于替换为现有项的交互调用，如果可能，所有指向发布的链接将重设为新创建的实例。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">iToReplace</span><span style=\"\">(PLMEntity)：要替换的实例。</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">iReplacingRef</span><span style=\"\">(PLMEntity)：此参考替换原有参考。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">- PLMEntity：此函数成功时创建的实例。</span><//p>";
CATKnowledge.ReplaceInstance.Sample="let carReference(VPMReference) \nlet engineInstance(VPMInstance) \nlet dieselEngine(VPMReference) \nlet gasEngine(VPMReference) \n\n[...]\n\nif paramEngineType == \"Gas\" \n{ \n\tReplaceInstance(engineInstance,gasEngine) \n} \nelse if paramEngineType == \"Diesel\" \n{ \n\tReplaceInstance(engineInstance,dieselEngine) \n} \n\n\n";


CATKnowledge.DeletePublication.Description="<p/><p><span style=\"font-weight:bold;font-size:12px;\">PLMEntity->DeletePublication</span><span style=\"font-size:12px;\"> </span><span style=\"\">可在参考上调用此方法以删除发布。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">pubname</span><span style=\"\">（字符串）：要删除的发布名称。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">无</span><//p>";
CATKnowledge.DeletePublication.Sample="let myRef(VPMReference)\n[...]\n\nmyRef->DeletePublication(\"ReferencePlane\") // myRef now has one less pub\n\n\n";

CATKnowledge.ListPublications.Description="<p/><p><span style=\"font-weight:bold;font-size:12px;\">PLMEntity->ListPublications</span><span style=\"font-size:12px;\">计算在指定参考下聚集的发布。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">无</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">- 列表：包含参考下的发布名称的字符串列表。</span><//p>";
CATKnowledge.ListPublications.Sample="let myRef(VPMReference) // Supposing myRef contains 3 publications named a,b and c \nlet listOfPubs(List)\nlet aFeature(Feature)\n[...]\n\nlistOfPubs = myRef->ListPublications()\n// listOfPubs will now contain \"a\", \"b\" and \"c\"\n\nmyRef->CreatePublication(NULL, aFeature,\"d\")\nlistOfPubs = myRef->ListPublications()\n// listOfPubs will now contain \"a\", \"b\", \"c\" and \"d\"\n\n";

CATKnowledge.IsPatternInstanceLocked.Description="<p><span style=\"font-weight:bold;font-size:12px;\"></span><//p><p><span style=\"font-weight:bold;font-size:12px;\">IsPatternInstanceLocked</span><span style=\"font-size:12px;\">检查在知识工程阵列中创建的特征是否已被锁定（请参阅 LockPatternInstance 了解更多信息）</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">patternInstance</span><span style=\"\">（特征）：通过 CreateOrModifyTemplate 或 CreateOrModifyDatum 创建的特征</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">- 布尔：如果此特征已被锁定，则为 TRUE，否则为 FALSE</span><//p><p/>";
CATKnowledge.IsPatternInstanceLocked.Sample="let currentFeature(Feature)\n\nfor currentFeature inside `Relations\Knowledge Pattern.1\List.1`\n{\n\tif IsPatternInstanceLocked(currentFeature) == FALSE \n\t{\n\t\t[...] // Modify the geometry here \n\t}\n}\n";

CATKnowledge.LockPatternInstance.Description="<p/><p><span style=\"font-weight:bold;font-size:12px;\">LockPatternInstance</span><span style=\"font-size:12px;\">可用于设置或取消设置防止通过 CreateOrModifyTemplate 或 CreateOrModifyDatum 在知识工程阵列中创建的特征上进行任何修改的锁定。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">patternInstance</span><span style=\"\">（特征）：要锁定或解锁的特征</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">doLock</span><span style=\"\">（布尔）：锁定为 TRUE，解锁为 FALSE </span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">无</span><//p><p/>";
CATKnowledge.LockPatternInstance.Sample="\n";

CATKnowledge.CreateOrModifyDatum.Description="<p><span style=\"font-weight:bold;color:rgb(0,0,0);font-size:12px;\"></span><//p><p><span style=\"font-weight:bold;font-size:12px;\">CreateOrModifyDatum</span><span style=\"font-size:12px;\"> 用于知识工程阵列，在目标实体中创建新的几何特征，并从阵列中将其存储在列表中。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">datumType</span><span style=\"\">(String)：基准类型。可以是点、直线、曲线、曲面、包络体、圆、平面</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">目标</span><span style=\"\">（特征）：实体集或几何图形集，用于存储创建的特征</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">patternList</span><span style=\"\">（列表）：将参考已创建元素的阵列列表</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">indexInPatternList</span><span style=\"\">（整数）：指示对象必须插入到列表中的位置的可选指数。默认行为是将结果附加到列表</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">- UndefinedType：创建的几何特征</span><//p><p/>";
CATKnowledge.CreateOrModifyDatum.Sample="/* Simple pattern creating points along a curve */\nlet i(Integer)\nlet currentPoint(Point)\nlet currentRatio(Real)\n\nfor i while i <= NumberOfPoints\n{\n\tcurrentRatio = i / NumberOfPoints\n\t// The first call creates and empty geometric feature\n\tcurrentPoint = CreateOrModifyDatum(\"Point\",PartBody, `Relations\Knowledge Pattern.1\List.1`)\n\t// The second call fills it with actual geometry\n\tcurrentPoint = pointoncurveRatio(MyPatternCurve,point(0,0,0), currentRatio, TRUE)\n}\n";

CATKnowledge.RemoveInstance.Description="<p><span style=\"font-weight:bold;color:rgb(0,0,0);font-size:12px;\"></span><//p><p><span style=\"font-weight:bold;font-size:12px;\">PLMEntity->RemoveInstance</span><span style=\"font-size:12px;\">从指定参考中移除实例</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">instanceName</span><span style=\"\">（字符串）：要移除的实例名称</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">无</span><//p>";
CATKnowledge.RemoveInstance.Sample="let myRef(VPMReference)\n\nmyRef->RemoveInstance(\"Wheel\") // Removes the instance named \"Wheel\" from myRef\n";

CATKnowledge.InstantiateTemplate.Description="<p/><p><span style=\"font-weight:bold;font-size:12px;\">InstantiateTemplate</span><span style=\"font-size:12px;\">从本地资源表或设置数据中开始模板（UDF、PowerCopy、工程模板、专有技术应用程序逻辑模板）的实例化。</span><//p><p><span style=\"text-decoration:underline;color:rgb(255,0,0);font-size:12px;\">/!\</span><span style=\"font-size:12px;\">每次调用此函数后都应对 EndModifyTemplate 进行匹配的调用。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">templateId (ARM)</span><span style=\"\">（字符串）：要实例化的模板，由其在逻辑资源表中的逻辑名称或设置数据条目设计</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">目标</span><span style=\"\">（特征）：实例化模板的目标。例如，UDP 或 PowerCopy 的实体或工程模板的参考。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">- UndefinedType：要进行实例化以便设置其输入和参数的模板。</span><//p><p/>";
CATKnowledge.InstantiateTemplate.Sample="/* This code instantiates a Template named TriangularPad which takes three points (defined on the template as A,B and C) as inputs and a length for the pad (called PadLength) as parameter. */\nlet templateInstance(Feature)\nlet p1,p2,p3(Point)\nlet destinationOfInstantiation(Feature)\n[...] /* Gather inputs here */\n\ntemplateInstance = InstantiateTemplate(\"TriangularPad\",destinationOfInstantiation)\nif templateInstance <> NULL \n{\n\t/* Set inputs */\n\ttemplateInstance->SetAttributeObject(\"A\",p1)\n\ttemplateInstance->SetAttributeObject(\"B\",p2)\n\ttemplateInstance->SetAttributeObject(\"C\",p3)\n\t/* Set Parameter */\n\ttemplateInstance->SetAttributeDimension(\"PadLength\",50mm,\"Length\")\n\tEndModifyTemplate(templateInstance)\n}\n\n";

CATKnowledge.CreateContextualConstraint.Description="<p/><p><span style=\"font-weight:bold;font-size:12px;\">VPMInstance->CreateContextualConstraint </span><span style=\"font-size:12px;\">类似于 CreateConstraint，除了创建的约束是上下文约束。可在参考下聚集上下文约束，但不指向参考外部的元素。此约束指向的所有元素都必须在装配体中有一个共同的上级，称为上下文。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">上下文</span><span style=\"\">(PLMEntity)：约束指向的所有元素的共同上级。</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">名称</span><span style=\"\">（字符串）：已创建约束的名称。如果需要创建此名称，则将把此名称指定给工程约束。</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">类型</span><span style=\"\">（字符串）：请参见 CreateConstraint。</span><//p><p><span style=\"\">- </span><span style=\"font-weight:bold;\">元素</span><span style=\"\">(ObjectType)：请参见 CreateConstraint。对于路径字符串元素，必须从上下文开始计算路径。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p><span style=\"\">- UndefinedType：此函数成功执行后创建的上下文 MRX。</span><//p>";
CATKnowledge.CreateContextualConstraint.Sample="";


CATKnowledge.ManageInstance.Description="<span style=\"font-weight:bold;font-size:12px;\">PLMEntity->ManageInstance</span><span style=\"font-size:12px;\"> 在其调用的参考下创建具有给定名称的新实例。如果已经存在具有同名的实例，其将被替换为新实例，且会自动重设链接（如适用）。</span><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p>- <span style=\"font-weight:bold;\">资源（目录、章节、产品、3D 形状） </span>来自本地资源表或数据设置中的资源逻辑路径。资源可以直接是产品或 3D 形状，也可以是目录、目录章节或部件系列。<//p><p>- <span style=\"font-weight:bold;\">queryExpression</span>（字符串）：当资源是目录、章节或部件系列时，此字符串是用于选择必须从集合实例化的参考的布尔表达式。使用产品或 3D 形状时可为空。<//p><p>- <span style=\"font-weight:bold;\">instanceName</span>（字符串）：要创建的实例的名称。<//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p>- PLMEntity：创建的实例<//p>";
CATKnowledge.ManageInstance.Sample="let fatherRef(VPMReference)\nlet createdInstance(VPMInstance)\n\n[...]\n\ncreatedInstance = fatherRef->ManageInstance(\"NutChapter\",\"Diameter==15mm\",\"NutInstance\")\n\n";

CATKnowledge.SetReplacingComponent.Description="<p><span style=\"font-weight:bold;font-size:12px;\">TemplateInstance->SetReplacingComponent</span><span style=\"font-size:12px;\"> 此方法让您能够在实例化工程模板时为模板的“要替换”部件（如已定义）设置替换部件。您可以通过使用 TemplateInstance 变量上的 ComponentsToReplace 属性获取要替换部件的列表。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">注意事项：</span><span style=\"font-size:12px;\"> 必须在调用任何 SetAttributeX 之前调用此函数才能更改模板实例的输入或参数。</span><br/><span style=\"font-size:12px;\"></span><br/><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p>- <span style=\"font-weight:bold;\">iToReplace</span>（特征）：实例化过程中要替换的原始部件<//p><p>- <span style=\"font-weight:bold;\">iReplacing</span>（特征）：iToReplace 的替换部件<//p><p><span style=\"font-weight:bold;font-size:12px;\">返回值：</span><//p><p>无<//p>";
CATKnowledge.SetReplacingComponent.Sample="";

CATKnowledge.Save.Description="<p><span style=\"font-weight:bold;font-size:12px;\">保存</span><span style=\"font-size:12px;\"> 将提供的列表内容保存为输入。如果无法进行保存操作，将显示错误。</span><//p><p><span style=\"font-weight:bold;font-size:12px;\">输入：</span><//p><p>- <span style=\"font-weight:bold;\">referencesToSave</span>(List): 要保存的元素列表，每个元素必须是 VPMReference，否则将出现错误。 <//p><p><span style=\"font-weight:bold;font-size:12px;\">返回的值：</span><//p><p>None<//p>";
CATKnowledge.Save.Sample="let ref1 (VPMReference)\n//Resource1 is defined in a Resource Table and contains an Engineering Template \n//this Template opens the result instead of instantiating it\n//obj is an input of the Engineering Template\nlet l(list)\nlet ti(TemplateInstance)\nti = InstantiateTemplate(\"Resource1\",NULL)\nl = ti.ComponentsToReplace\nset ref1 = l.GetItem(1)\nti.SetReplacingComponent(ref1, obj)\nEndModifyTemplate(ti)\n//We save the created elements\nSave(ti.CreatedReferences) ";
